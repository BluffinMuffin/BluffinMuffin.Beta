package backend.agent;

import java.util.ArrayList;

import pokerStats.MonteCarlo;

import utility.TypePlayerAction;
import backend.PlayerAction;
import basePoker.Card;

/**
 * @author Hocus
 *         This Poker AI use the same algorithm as the pokerBasic AI
 *         but with different parameters. The parameters were generated
 *         by a genetic algorithm.
 */

public class PokerGeneticBasic extends PokerAI
{
    private final static int NB_SIMULATIONS = 10000;
    
    // The ADN Generated by a genetic algorithm
    private final double[] m_adn = new double[] { 0.6, 0.3266700514469202, 0.22182060907102807, 0.25, 0.08723920632011439, 0.2362120951148745 };
    
    // Second working ADN: {0.6, 0.21131060545158453, 0.37403662092474566,
    // 0.6975896343117947, 0.8464545870554965, 0.26968160234329386};
    
    public PokerGeneticBasic()
    {
    }
    
    @Override
    protected PlayerAction analyze(ArrayList<TypePlayerAction> p_actionsAllowed, int p_minRaiseAmount, int p_maxRaiseAmount)
    {
        final Card[] myCards = new Card[] { m_table.m_localPlayer.m_card1, m_table.m_localPlayer.m_card2 };
        final Card[] myBoardCards = m_table.m_boardCards.toArray(new Card[m_table.m_boardCards.size()]);
        
        System.out.println("Calculating MonteCarlo score...");
        
        if ((myCards[0] == null) || (myCards[1] == null))
        {
            System.err.println("Watch IT!!! Cannot take decision if I don't hava any cards.");
            return super.analyze(p_actionsAllowed, p_minRaiseAmount, p_maxRaiseAmount);
        }
        
        final double score = MonteCarlo.CalculateWinRatio(myCards, myBoardCards, m_table.m_nbRemainingPlayers, PokerGeneticBasic.NB_SIMULATIONS).m_winRatio;
        
        System.out.println("Analyzing " + score);
        final double x = m_table.m_nbRemainingPlayers;
        final double threshold1 = Math.sqrt(m_adn[0] * (1.0 / (x - m_adn[1]))) + m_adn[2];
        final double threshold2 = Math.sqrt(1.0 / (m_adn[3] * (x + (1 / m_adn[4])))) - m_adn[5];
        
        if ((score >= threshold1) && p_actionsAllowed.contains(TypePlayerAction.RAISE))
        {
            return new PlayerAction(TypePlayerAction.RAISE, Math.min(p_minRaiseAmount + m_table.m_smallBlindAmount, p_maxRaiseAmount));
        }
        else if ((score >= threshold2) && p_actionsAllowed.contains(TypePlayerAction.CALL))
        {
            return new PlayerAction(TypePlayerAction.CALL);
        }
        else
        {
            if (p_actionsAllowed.contains(TypePlayerAction.CHECK))
            {
                return new PlayerAction(TypePlayerAction.CHECK);
            }
            else
            {
                return new PlayerAction(TypePlayerAction.FOLD);
            }
        }
    }
    
    @Override
    public String toString()
    {
        return "Poker Basic AI";
    }
}
