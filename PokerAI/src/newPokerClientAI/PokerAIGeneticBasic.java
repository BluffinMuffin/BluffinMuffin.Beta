package newPokerClientAI;

import gameLogic.GameCard;
import newPokerLogic.IPokerGame;
import newPokerLogic.PokerPlayerInfo;
import newPokerLogic.PokerTableInfo;
import pokerStats.MonteCarlo;

/**
 * @author Hocus
 *         This Poker AI use the same algorithm as the pokerBasic AI
 *         but with different parameters. The parameters were generated
 *         by a genetic algorithm.
 */

public class PokerAIGeneticBasic extends AbstractPokerAI
{
    public PokerAIGeneticBasic(IPokerGame game, int seatViewed)
    {
        super(game, seatViewed);
    }
    
    private final static int NB_SIMULATIONS = 10000;
    
    // The ADN Generated by a genetic algorithm
    private final double[] m_adn = new double[] { 0.6, 0.3266700514469202, 0.22182060907102807, 0.25, 0.08723920632011439, 0.2362120951148745 };
    
    // Second working ADN: {0.6, 0.21131060545158453, 0.37403662092474566,
    // 0.6975896343117947, 0.8464545870554965, 0.26968160234329386};
    
    @Override
    protected int playMoney()
    {
        
        final PokerTableInfo table = m_game.getPokerTable();
        final PokerPlayerInfo p = table.getPlayer(m_currentTablePosition);
        final GameCard[] myCards = p.getCurrentHand(true);
        final GameCard[] myBoardCards = new GameCard[5];
        table.getCurrentBoardCards().toArray(myBoardCards);
        
        System.out.println("Calculating MonteCarlo score...");
        
        // Verifying that we agent two cards in our hand.
        if ((myCards[0] == null) || (myCards[1] == null))
        {
            System.err.println("Watch IT!!! Cannot take decision if I don't hava any cards.");
            return super.playMoney();
        }
        
        // Calculate Monte Carlo scoreï¿½
        final double score = MonteCarlo.CalculateWinRatio(myCards, myBoardCards, table.getNbPlaying(), PokerAIGeneticBasic.NB_SIMULATIONS).m_winRatio;
        
        System.out.println("Analyzing " + score);
        final int x = table.getNbPlaying();
        final double threshold1 = Math.sqrt(m_adn[0] * (1.0 / (x - m_adn[1]))) + m_adn[2];
        final double threshold2 = Math.sqrt(1.0 / (m_adn[3] * (x + (1 / m_adn[4])))) - m_adn[5];
        
        final boolean canRaise = table.getCurrentHigherBet() >= (p.getCurrentBetMoneyAmount() + p.getCurrentSafeMoneyAmount());
        final boolean canCheck = table.getCurrentHigherBet() == p.getCurrentBetMoneyAmount();
        
        if ((score >= threshold1) && canRaise)
        {
            final int restant = (p.getCurrentBetMoneyAmount() + p.getCurrentSafeMoneyAmount()) - table.getCurrentHigherBet();
            return Math.min((table.getCurrentHigherBet() + table.getBigBlindAmount()) - p.getCurrentBetMoneyAmount(), restant);
        }
        else if ((score >= threshold2))
        {
            return table.getCurrentHigherBet() - p.getCurrentBetMoneyAmount();
        }
        else
        {
            if (canCheck)
            {
                return 0;
            }
            else
            {
                return -1;
            }
        }
    }
    
    @Override
    public String toString()
    {
        return "Poker Basic AI";
    }
}
